/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.0.0.0 (NJsonSchema v9.1.11.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as jQuery from 'jquery';

export namespace TaskServiceAPI {

    export class Client {
        baseUrl: string;
        beforeSend: any = undefined;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string) {
            this.baseUrl = baseUrl ? baseUrl : "";
        }

        /**
         * @return Success
         */
        apiTasksGet() {
            return new Promise<Task[] | null>((resolve, reject) => {
                this.apiTasksGetWithCallbacks((result) => resolve(result), (exception, _reason) => reject(exception));
            });
        }

        private apiTasksGetWithCallbacks(onSuccess?: (result: Task[] | null) => void, onFail?: (exception: string, reason: string) => void) {
            let url_ = this.baseUrl + "/api/Tasks";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = "";

            jQuery.ajax({
                url: url_,
                beforeSend: this.beforeSend,
                type: "get",
                data: content_,
                dataType: "text",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            }).done((_data, _textStatus, xhr) => {
                this.processApiTasksGetWithCallbacks(url_, xhr, onSuccess, onFail);
            }).fail((xhr) => {
                this.processApiTasksGetWithCallbacks(url_, xhr, onSuccess, onFail);
            });
        }

        private processApiTasksGetWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
            try {
                let result = this.processApiTasksGet(xhr);
                if (onSuccess !== undefined)
                    onSuccess(result);
            } catch (e) {
                if (onFail !== undefined)
                    onFail(e, "http_service_exception");
            }
        }

        protected processApiTasksGet(xhr: any): Task[] | null | null {
            const status = xhr.status;

            if (status === 200) {
                const _responseText = xhr.responseText;
                let result200: Task[] | null = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Task.fromJS(item));
                }
                return result200;
            } else if (status !== 200 && status !== 204) {
                const _responseText = xhr.responseText;
                return throwException("An unexpected server error occurred.", status, _responseText);
            }
            return null;
        }

        /**
         * @task (optional) 
         * @return Success
         */
        apiTasksPost(task: Task) {
            return new Promise<void>((resolve, reject) => {
                this.apiTasksPostWithCallbacks(task, (result) => resolve(result), (exception, _reason) => reject(exception));
            });
        }

        private apiTasksPostWithCallbacks(task: Task, onSuccess?: (result: void) => void, onFail?: (exception: string, reason: string) => void) {
            let url_ = this.baseUrl + "/api/Tasks";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(task ? task.toJSON() : null);

            jQuery.ajax({
                url: url_,
                beforeSend: this.beforeSend,
                type: "post",
                data: content_,
                dataType: "text",
                headers: {
                    "Content-Type": "application/json",
                }
            }).done((_data, _textStatus, xhr) => {
                this.processApiTasksPostWithCallbacks(url_, xhr, onSuccess, onFail);
            }).fail((xhr) => {
                this.processApiTasksPostWithCallbacks(url_, xhr, onSuccess, onFail);
            });
        }

        private processApiTasksPostWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
            try {
                let result = this.processApiTasksPost(xhr);
                if (onSuccess !== undefined)
                    onSuccess(result);
            } catch (e) {
                if (onFail !== undefined)
                    onFail(e, "http_service_exception");
            }
        }

        protected processApiTasksPost(xhr: any): void | null {
            const status = xhr.status;

            if (status === 200) {
                const _responseText = xhr.responseText;
                return;
            } else if (status !== 200 && status !== 204) {
                const _responseText = xhr.responseText;
                return throwException("An unexpected server error occurred.", status, _responseText);
            }
            return;
        }

        /**
         * @return Success
         */
        apiTasksByIdGet(id: string) {
            return new Promise<Task | null>((resolve, reject) => {
                this.apiTasksByIdGetWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
            });
        }

        private apiTasksByIdGetWithCallbacks(id: string, onSuccess?: (result: Task | null) => void, onFail?: (exception: string, reason: string) => void) {
            let url_ = this.baseUrl + "/api/Tasks/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = "";

            jQuery.ajax({
                url: url_,
                beforeSend: this.beforeSend,
                type: "get",
                data: content_,
                dataType: "text",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            }).done((_data, _textStatus, xhr) => {
                this.processApiTasksByIdGetWithCallbacks(url_, xhr, onSuccess, onFail);
            }).fail((xhr) => {
                this.processApiTasksByIdGetWithCallbacks(url_, xhr, onSuccess, onFail);
            });
        }

        private processApiTasksByIdGetWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
            try {
                let result = this.processApiTasksByIdGet(xhr);
                if (onSuccess !== undefined)
                    onSuccess(result);
            } catch (e) {
                if (onFail !== undefined)
                    onFail(e, "http_service_exception");
            }
        }

        protected processApiTasksByIdGet(xhr: any): Task | null | null {
            const status = xhr.status;

            if (status === 200) {
                const _responseText = xhr.responseText;
                let result200: Task | null = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Task.fromJS(resultData200) : new Task();
                return result200;
            } else if (status !== 200 && status !== 204) {
                const _responseText = xhr.responseText;
                return throwException("An unexpected server error occurred.", status, _responseText);
            }
            return null;
        }

        /**
         * @task (optional) 
         * @return Success
         */
        apiTasksByIdPut(id: string, task: Task) {
            return new Promise<void>((resolve, reject) => {
                this.apiTasksByIdPutWithCallbacks(id, task, (result) => resolve(result), (exception, _reason) => reject(exception));
            });
        }

        private apiTasksByIdPutWithCallbacks(id: string, task: Task, onSuccess?: (result: void) => void, onFail?: (exception: string, reason: string) => void) {
            let url_ = this.baseUrl + "/api/Tasks/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(task ? task.toJSON() : null);

            jQuery.ajax({
                url: url_,
                beforeSend: this.beforeSend,
                type: "put",
                data: content_,
                dataType: "text",
                headers: {
                    "Content-Type": "application/json",
                }
            }).done((_data, _textStatus, xhr) => {
                this.processApiTasksByIdPutWithCallbacks(url_, xhr, onSuccess, onFail);
            }).fail((xhr) => {
                this.processApiTasksByIdPutWithCallbacks(url_, xhr, onSuccess, onFail);
            });
        }

        private processApiTasksByIdPutWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
            try {
                let result = this.processApiTasksByIdPut(xhr);
                if (onSuccess !== undefined)
                    onSuccess(result);
            } catch (e) {
                if (onFail !== undefined)
                    onFail(e, "http_service_exception");
            }
        }

        protected processApiTasksByIdPut(xhr: any): void | null {
            const status = xhr.status;

            if (status === 200) {
                const _responseText = xhr.responseText;
                return;
            } else if (status !== 200 && status !== 204) {
                const _responseText = xhr.responseText;
                return throwException("An unexpected server error occurred.", status, _responseText);
            }
            return;
        }

        /**
         * @return Success
         */
        apiTasksByIdDelete(id: string) {
            return new Promise<void>((resolve, reject) => {
                this.apiTasksByIdDeleteWithCallbacks(id, (result) => resolve(result), (exception, _reason) => reject(exception));
            });
        }

        private apiTasksByIdDeleteWithCallbacks(id: string, onSuccess?: (result: void) => void, onFail?: (exception: string, reason: string) => void) {
            let url_ = this.baseUrl + "/api/Tasks/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id));
            url_ = url_.replace(/[?&]$/, "");

            const content_ = "";

            jQuery.ajax({
                url: url_,
                beforeSend: this.beforeSend,
                type: "delete",
                data: content_,
                dataType: "text",
                headers: {
                    "Content-Type": "application/json",
                }
            }).done((_data, _textStatus, xhr) => {
                this.processApiTasksByIdDeleteWithCallbacks(url_, xhr, onSuccess, onFail);
            }).fail((xhr) => {
                this.processApiTasksByIdDeleteWithCallbacks(url_, xhr, onSuccess, onFail);
            });
        }

        private processApiTasksByIdDeleteWithCallbacks(_url: string, xhr: any, onSuccess?: any, onFail?: any): void {
            try {
                let result = this.processApiTasksByIdDelete(xhr);
                if (onSuccess !== undefined)
                    onSuccess(result);
            } catch (e) {
                if (onFail !== undefined)
                    onFail(e, "http_service_exception");
            }
        }

        protected processApiTasksByIdDelete(xhr: any): void | null {
            const status = xhr.status;

            if (status === 200) {
                const _responseText = xhr.responseText;
                return;
            } else if (status !== 200 && status !== 204) {
                const _responseText = xhr.responseText;
                return throwException("An unexpected server error occurred.", status, _responseText);
            }
            return;
        }
    }

    export class Task implements ITask {
        id?: string | undefined;
        code: string;
        title: string;
        content?: string | undefined;
        created?: Date | undefined;
        updated?: Date | undefined;
        creator?: string | undefined;
        assignee?: string | undefined;

        constructor(data?: ITask) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }

        init(data?: any) {
            if (data) {
                this.id = data["id"];
                this.code = data["code"];
                this.title = data["title"];
                this.content = data["content"];
                this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
                this.updated = data["updated"] ? new Date(data["updated"].toString()) : <any>undefined;
                this.creator = data["creator"];
                this.assignee = data["assignee"];
            }
        }

        static fromJS(data: any): Task {
            let result = new Task();
            result.init(data);
            return result;
        }

        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["code"] = this.code;
            data["title"] = this.title;
            data["content"] = this.content;
            data["created"] = this.created ? this.created.toISOString() : <any>undefined;
            data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
            data["creator"] = this.creator;
            data["assignee"] = this.assignee;
            return data;
        }
    }

    export interface ITask {
        id?: string | undefined;
        code: string;
        title: string;
        content?: string | undefined;
        created?: Date | undefined;
        updated?: Date | undefined;
        creator?: string | undefined;
        assignee?: string | undefined;
    }

    export class SwaggerException extends Error {
        message: string;
        status: number;
        response: string;
        result: any;

        constructor(message: string, status: number, response: string, result: any) {
            super();

            this.message = message;
            this.status = status;
            this.response = response;
            this.result = result;
        }
    }

    function throwException(message: string, status: number, response: string, result?: any): any {
        if (result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }

}